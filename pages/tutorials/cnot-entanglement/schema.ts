import * as s from "@/schema/tutorial";

export default s.tutorial({
  pages: {
    otherTwoQubitGates: s.page(),
    entanglement: s.page(),
    anEntangledBasis: s.page(),
    consequencesOfEntanglement: s.page(),
  },
  pretest: {
    outputIHCNOT11: s.string(),
    isOutputIHCNOT11Entangled: s.chooseOne([
      "entangled",
      "not entangled",
      "unsure",
    ]),
    threeQubitOutputStateEntangled: s.chooseOne([
      "entangled",
      "not entangled",
      "it depends",
      "unsure",
    ]),
  },
  posttest: {
    outputIHCNOT11: s.string(),
    isOutputIHCNOT11Entangled: s.chooseOne(["entangled", "not entangled"]),
    threeQubitOutputStateEntangled: s.chooseOne([
      "entangled",
      "not entangled",
      "it depends",
    ]),
  },
  sections: {
    otherTwoQubitGatesIntro: s.section(),
    writeCNOTAsMatrix: s.section(),
    canFactorCNOT: s.section(),
    dirac01HICNOT: s.section({ messages: ["dynamicAnswer"] }),
    output01HICNOT: s.section(),
    // output00HICNOTProp0Qubit1: s.section(),
    output01HICNOTProp0Qubit1: s.section(),
    // output00HICNOTProp1Qubit2: s.section(),
    output01HICNOTProp0Qubit2: s.section(),
    // output00HICNOTProb01Qubit2: s.section(),
    output01HICNOTProb00Qubit2: s.section(),

    entanglementIntro: s.section(),
    is00Plus01Entangled: s.section(),
    isEquationEntangledTwo: s.section(),
    considerBeta11: s.section(),
    measuringBeta11Qubit1: s.section(),
    measuringBeta11Qubit2: s.section(),
    differenceBetweenQuestionsComment: s.section(),
    measuringSuperpositionState: s.section(),

    anEntangledBasisIntro: s.section(),
    circuitToGenerateBellStates: s.section(),
    beforeAndAfterCNOT: s.section(),
    circuitToDisentangleBeta00: s.section(),

    consequencesOfEntanglementIntro: s.section(),
    introducingAliceAndBob: s.section(),
    didAliceSendMessageToBob: s.section(),
    fasterThanLight: s.section(),
  },
  responses: {
    CNOTMatrix33: s.number(),
    CNOTMatrix34: s.number(),
    CNOTMatrix43: s.number(),
    CNOTMatrix44: s.number(),
    canFactorCNOT: s.chooseOne(["yes", "no"]),
    dirac01HICNOT: s.chooseAll([
      "response1",
      "(U_CNOT)(HxI)(0x1)",
      "(U_CNOT)(IxH)(0x1)",
      "(U_CNOT)(HxI)(01)", //did not choose to add these, but it's an option
      "(U_CNOT)(H0x1)",
      "(U_CNOT)(0xH1)",
      "U_CNOT(H0)xU_CNOT(1)",
      "U_CNOT(0)xU_CNOT(H1)",
      "(HxI)(U_CNOT)(0x1)",
      "(IxH)(U_CNOT)(0x1)",
      "(HxI)(U_CNOT)(01)", //did not choose to add these, but it's an option
    ]),
    output01HICNOT: s.string(),
    // output00HICNOTProp0Qubit1: s.number(),
    // output00HICNOTProp1Qubit2: s.number(),
    // output00HICNOTProb01Qubit2: s.number(),
    output01HICNOTProp0Qubit1: s.number(),
    output01HICNOTProp0Qubit2: s.number(),
    output01HICNOTProb00Qubit2: s.number(),

    is00Plus01EntangledExplain: s.string(),
    is00Plus01Entangled: s.chooseOne(["entangled", "not entangled"]),
    isEquationEntangledTwoExplanation: s.string(),
    isBeta01Entangled: s.chooseOne(["entangled", "not entangled"]),
    isProbQubit1Beta11FiftyFifty: s.chooseOne(["yes", "no"]),
    isStateQubit1Beta11Minus: s.chooseOne(["yes", "no"]),
    isStateQubit1Beta11Arbitrary: s.chooseOne(["yes", "no"]),
    probBeta11Qubit1is0: s.number(),
    probBeta11Qubit2is0: s.number(),
    stateOfQubit1WhenBeta11Qubit2is0: s.string(),
    probQubit1is0WhenBeta11Qubit2is0: s.number(),
    probQubit2is1: s.number(),
    resultingStateQubit1: s.string(),

    beforeCNOT: s.chooseOne(["yes", "no"]),
    outputBeta00CNOTHI: s.string(),
    afterCNOT: s.chooseOne(["yes", "no"]),
    isBeta00Entangled: s.chooseOne(["yes", "no"]),
    isBeta00EntangledAfterCNOT: s.chooseOne(["yes", "no"]),
    outputStateOfCircuit: s.string(),
    isOutputBeta00CNOTHIEntangled: s.chooseOne(["yes", "no"]),

    didAliceSendMessageToBob: s.chooseOne(["yes", "no"]),
    didAliceSendMessageToBobExplain: s.string(),
    fasterThanLight: s.string(),
  },
  hints: {
    gateIsLinear: s.hint(),
  },
});
